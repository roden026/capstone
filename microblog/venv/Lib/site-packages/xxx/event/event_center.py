# -*— coding:utf-8 -*-

"""
事件处理中心

Author: huangtao
Date:   2018/05/04
Update: None
"""

import asyncio

import aioamqp

from xxx.utils import logger
from xxx.config import config
from xxx.event.event import Event


__all__ = ('event_center', )


class EventCenter:
    """ 事件处理中心
    """

    def __init__(self):
        self._host = config.rabbitmq.get('host', 'localhost')
        self._port = config.rabbitmq.get('port', 5672)
        self._username = config.rabbitmq.get('username', 'guest')
        self._password = config.rabbitmq.get('password', 'guest')
        self.channel = None # 连接通道
        self._connected = False # 是否连接成功
        self._lock = asyncio.Lock() # 在订阅事件回调的时候，需要控制订阅顺序，不能并发订阅，所以用锁来控制
        self._consume_queues = set() # 消费队列
        self._event_handler = {} # 事件对应的处理函数 {"exchange": {"event_name": [callback_function1, ...]}}

    def initialize(self):
        """ 初始化
        """
        asyncio.get_event_loop().run_until_complete(self._connect())
        asyncio.get_event_loop().call_later(5, self._start_consume)

    async def subscribe(self, event, callback, broadcast=True, bind_queue=True):
        """ 注册事件
        @param event 事件
        @param callback 回调函数
        @param broadcast 交换机是否需要广播消息
        @param bind_queue 此事件是否需要绑定队列接收消息
        """
        await self._lock.acquire()
        logger.info('EXCHANGE:', event.EXCHANGE, 'QUEUE:', event.QUEUE, 'NAME:', event.NAME, caller=self)
        await self._initialize(event, broadcast, bind_queue)
        self._add_event_handler(event, callback)
        self._lock.release()

    async def publish(self, event):
        """ 发布消息
        @param event 发布的事件对象
        @param exchange 发布消息的交换机
        """
        if not self._connected:
            logger.warn('RabbitMQ not ready right now!', caller=self)
            return
        data = event.dumps()
        await self.channel.basic_publish(payload=data, exchange_name=event.exchange, routing_key='')

    async def _connect(self):
        """ 建立TCP连接
        """
        logger.debug('host:', self._host, 'port:', self._port, caller=self)
        if self._connected:
            return
        transport, protocol = await aioamqp.connect(host=self._host, port=self._port, login=self._username,
                                                    password=self._password)
        channel = await protocol.channel()
        self.channel = channel
        self._connected = True
        logger.info('Rabbitmq initialize success!', caller=self)

    def _start_consume(self):
        """ 开始消费事件消息
        * NOTE: 此函数延迟执行（5秒），等待所有事件都订阅成功之后，再开始消费消息
        """
        async def do_comsume():
            for queue in self._consume_queues:
                logger.info('queue:', queue, caller=self)
                await self.channel.basic_consume(self._on_consume_event_msg, queue_name=queue)
        asyncio.get_event_loop().create_task(do_comsume())

    async def _initialize(self, event, broadcast=True, bind_queue=True):
        """ 创建/绑定交易所相关消息队列
        @param event 订阅的事件
        @param broadcast 交换机是否需要广播消息
        @param bind_queue 此事件是否需要绑定队列接收消息
        """
        # 声明交换机
        if broadcast:
            await self.channel.exchange_declare(exchange_name=event.EXCHANGE, type_name='fanout')
        else:
            await self.channel.exchange_declare(exchange_name=event.EXCHANGE, type_name='direct')

        # 是否需要绑定队列接收消息
        if bind_queue:
            if event.QUEUE:
                await self.channel.queue_declare(queue_name=event.QUEUE)
                queue_name = event.QUEUE
            else:
                result = await self.channel.queue_declare(exclusive=True)
                queue_name = result['queue']
            await self.channel.queue_bind(queue_name=queue_name, exchange_name=event.EXCHANGE, routing_key='')
            await self.channel.basic_qos(prefetch_count=event.PRE_FETCH_COUNT) # 消息窗口大小，越大，消息推送越快，但也需要处理越快
            self._consume_queues.add(queue_name)
            # await self.channel.basic_consume(self._on_consume_event_msg, queue_name=queue_name)

    async def _on_consume_event_msg(self, channel, body, envelope, properties):
        """ 收到订阅的事件消息
        @param channel 消息队列通道
        @param body 接收到的消息
        @param envelope
        @param properties 消息属性(发布消息时候携带)
        """
        try:
            e = Event()
            e.loads(body.decode())
        except:
            logger.error('event format error! body:', body, caller=self)
            return
        # logger.debug('body:', body, caller=self)

        if envelope.exchange_name not in self._event_handler:
            logger.error('event exchange not found! event:', e, caller=self)
            return
        if e.name not in self._event_handler[envelope.exchange_name]:
            logger.error('event name not found! event:', e, caller=self)
            return

        # 执行事件回调函数
        funcs = self._event_handler[envelope.exchange_name][e.name]
        for func in funcs:
            asyncio.get_event_loop().create_task(func(e))
            # await func(e)

        # response ack
        await self.channel.basic_client_ack(delivery_tag=envelope.delivery_tag)

    def _add_event_handler(self, event, callback):
        """ 增加事件处理回调函数
        * NOTE: {"exchange": {"event_name": [callback_function, ...]}}
        """
        if event.EXCHANGE in self._event_handler:
            if event.NAME in self._event_handler[event.EXCHANGE]:
                self._event_handler[event.EXCHANGE][event.NAME].append(callback)
            else:
                self._event_handler[event.EXCHANGE][event.NAME] = [callback]
        else:
            self._event_handler[event.EXCHANGE] = {event.NAME: [callback]}
        logger.info('self._event_handler:', self._event_handler, caller=self)


event_center = EventCenter()
